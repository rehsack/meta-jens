# Base class for creating updatable-container bundles or updatable-container wic images
#
# Description:
#
# You have to set the slot images in your recipe file following this example:
#
#   UPDATABLE_BUNDLE_COMPATIBLE ?= "My Super Product"
#   UPDATABLE_BUNDLE_VERSION ?= "v2015-06-07-1"
#
#   UPDATABLE_BUNDLE_HOOKS ?= "install-check resize-rootfs"
#   UPDATABLE_BUNDLE_HOOK_resize-rootfs[type] ?= "inline"
#   UPDATABLE_BUNDLE_HOOK_resize-rootfs[trigger] ?= "postextract"
#   UPDATABLE_BUNDLE_HOOK_resize-rootfs[code] ?= "resize2fs ..."
#   UPDATABLE_BUNDLE_HOOK_install-check[type] ?= "script"
#   UPDATABLE_BUNDLE_HOOK_install-check[trigger] ?= "onfinish"
#   UPDATABLE_BUNDLE_HOOK_install-check[src] ?= "install-check"
#
#   UPDATABLE_BUNDLE_SLOTS ?= "rootfs kernel dtb bootloader"
#
#   UPDATABLE_SLOT_rootfs ?= "core-image-minimal"
#   UPDATABLE_SLOT_rootfs[fstype] = "ext4"
#   UPDATABLE_SLOT_rootfs[hooks] ?= "install;post-install"
#
#   UPDATABLE_SLOT_kernel ?= "linux-yocto"
#   UPDATABLE_SLOT_kernel[type] ?= "kernel"
#   
#   UPDATABLE_SLOT_bootloader ?= "barebox"
#   UPDATABLE_SLOT_bootloader[type] ?= "boot"
#   UPDATABLE_SLOT_bootloader[file] ?= "barebox.img"
#
#   UPDATABLE_SLOT_dtb ?= linux-yocto
#   UPDATABLE_SLOT_dtb[type] ?= "file"
#   UPDATABLE_SLOT_dtb[file] ?= "${MACHINE}.dtb"
#
# To use a different image name, e.g. for variants
#   UPDATABLE_SLOT_dtb ?= linux-yocto
#   UPDATABLE_SLOT_dtb[name] ?= "dtb.my,compatible"
#   UPDATABLE_SLOT_dtb[type] ?= "file"
#   UPDATABLE_SLOT_dtb[file] ?= "${MACHINE}-variant1.dtb"
#
# To override the file name used in the bundle use 'rename'
#   UPDATABLE_SLOT_rootfs ?= "core-image-minimal"
#   UPDATABLE_SLOT_rootfs[rename] ?= "rootfs.ext4"
#
# To add additional artifacts to the bundle you can use UPDATABLE_BUNDLE_EXTRA_FILES
# and UPDATABLE_BUNDLE_EXTRA_DEPENDS.
# For files from the WORKDIR (fetched using SRC_URI) you can write:
#
#   SRC_URI += "file://myfile"
#   UPDATABLE_BUNDLE_EXTRA_FILES += "myfile"
#
# For files from the DEPLOY_DIR_IMAGE (generated by another recipe) you can write:
#
#   UPDATABLE_BUNDLE_EXTRA_DEPENDS += "myfile-recipe-pn"
#   UPDATABLE_BUNDLE_EXTRA_FILES += "myfile.img"
#
# Extra arguments may be passed to the bundle command with BUNDLE_ARGS eg:
#   BUNDLE_ARGS += ' --mksquashfs-args="-comp zstd -Xcompression-level 22" '
#
# Likewise, extra arguments can be passed to the convert command with
# CONVERTS_ARGS.
#
# Additionally you need to provide a certificate and a key file
#
#   UPDATABLE_KEY_FILE ?= "development-1.key.pem"
#
# ...
#
#   UPDATABLE_BUNDLE_BOOTLOADER_TYPE (msdos, gpt)

UPDATABLE_BUNDLE_COMPATIBLE              ??= "${MACHINE}-${WANTED_ROOT_DEV}-${TARGET_VENDOR}"
UPDATABLE_BUNDLE_VERSION                 ??= "${PV}"
UPDATABLE_BUNDLE_MIN_BOOTLOADER_VERSION  ??= "${PV}"
UPDATABLE_BUNDLE_DESCRIPTION             ??= "${SUMMARY}"
UPDATABLE_BUNDLE_BUILD                   ??= "${DATETIME}"
UPDATABLE_BUNDLE_DEVELOPER_BUILD         ??= "0"
UPDATABLE_BUNDLE_DEVELOPER_IMAGE_EXTNAME ??= ""
UPDATABLE_BUNDLE_BUILD[vardepsexclude] = "DATETIME"
UPDATABLE_BUNDLE_COMPATIBLE[doc] = "Specifies the mandatory bundle compatible string. See UPDATABLE documentation for more details."
UPDATABLE_BUNDLE_VERSION[doc] = "Specifies the bundle version string. See UPDATABLE documentation for more details."
UPDATABLE_BUNDLE_MIN_BOOTLOADER_VERSION[doc] = "Specifies the minimum bootloader version for this update. See UPDATABLE documentation for more details."
UPDATABLE_BUNDLE_DESCRIPTION[doc] = "Specifies the bundle description string. See UPDATABLE documentation for more details."
UPDATABLE_BUNDLE_BUILD[doc] = "Specifies the bundle build stamp. See UPDATABLE documentation for more details."

UPDATABLE_BUNDLE_SLOTS[doc] = "Space-separated list of slot classes to include in bundle (manifest)"
UPDATABLE_BUNDLE_HOOKS[doc] = "Allows to specify an additional hook executable and bundle hooks"

UPDATABLE_BUNDLE_EXTRA_FILES[doc] = "Specifies list of additional files to add to bundle. Files must either be located in WORKDIR (added by SRC_URI) or DEPLOY_DIR_IMAGE (assured by UPDATABLE_BUNDLE_EXTRA_DEPENDS)"
UPDATABLE_BUNDLE_EXTRA_DEPENDS[doc] = "Specifies list of recipes that create artifacts in DEPLOY_DIR_IMAGE. For recipes not depending on do_deploy task also <recipename>:do_<taskname> notation is supported"

# UPDATABLE_CASYNC_BUNDLE ??= "0"

# Create dependency list from images
python __anonymous() {
    d.appendVarFlag('do_unpack', 'vardeps', ' UPDATABLE_BUNDLE_HOOKS')
    for slot in (d.getVar('UPDATABLE_BUNDLE_SLOTS') or "").split():
        slot_flags = d.getVarFlags('UPDATABLE_SLOT_%s' % slot)
        imgtype = slot_flags.get('type') if slot_flags else None
        if not imgtype:
            bb.debug(1, "No [type] given for slot '%s', defaulting to 'image'" % slot)
            imgtype = 'image'
        image = d.getVar('UPDATABLE_SLOT_%s' % slot)

        if not image:
            bb.error("No image set for slot '%s'. Specify via 'UPDATABLE_SLOT_%s = \"<recipe-name>\"'" % (slot, slot))
            return

        d.appendVarFlag('do_unpack', 'vardeps', ' UPDATABLE_SLOT_%s' % slot)
        depends_u = slot_flags.get('depends') if slot_flags else None
        depends = d.expand(depends_u)
        if depends:
            d.appendVarFlag('do_unpack', 'depends', ' ' + depends)
            continue

        if imgtype == 'image':
            d.appendVarFlag('do_unpack', 'depends', ' ' + image + ':do_image_complete')
        else:
            d.appendVarFlag('do_unpack', 'depends', ' ' + image + ':do_deploy')

    for image in (d.getVar('UPDATABLE_BUNDLE_EXTRA_DEPENDS') or "").split():
        imagewithdep = image.split(':')
        deptask = imagewithdep[1] if len(imagewithdep) > 1 else 'do_deploy'
        d.appendVarFlag('do_unpack', 'depends', ' %s:%s' % (image, deptask))
        bb.note('adding extra dependency %s:%s' % (image,  deptask))
}

